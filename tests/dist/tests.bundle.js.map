{"version":3,"file":"tests.bundle.js","sources":["../../../../../../.nuget/packages/fable.core/1.3.11/fable-core/Date.js","../../../../../../.nuget/packages/fable.core/1.3.11/fable-core/Symbol.js","../../../../../../.nuget/packages/fable.core/1.3.11/fable-core/Util.js","../../../../../../.nuget/packages/fable.core/1.3.11/fable-core/Option.js","../../../../../../.nuget/packages/fable.core/1.3.11/fable-core/ListClass.js","../../../../../../.nuget/packages/fable.core/1.3.11/fable-core/Seq.js","../../../../../../.nuget/packages/fable.core/1.3.11/fable-core/List.js","../../../../../../.nuget/packages/fable.core/1.3.11/fable-core/RegExp.js","../../src/HtmlParser/Parser.Tokenizer.fs","../Tests.Tokenizer.fs","../Main.fs"],"sourcesContent":["export const offsetRegex = /(?:Z|[+-](\\d{2}):?(\\d{2})?)$/;\nexport function padWithZeros(i, length) {\n    let str = i.toString(10);\n    while (str.length < length) {\n        str = \"0\" + str;\n    }\n    return str;\n}\nexport function offsetToString(offset) {\n    const isMinus = offset < 0;\n    offset = Math.abs(offset);\n    const hours = ~~(offset / 3600000);\n    const minutes = (offset % 3600000) / 60000;\n    return (isMinus ? \"-\" : \"+\") +\n        padWithZeros(hours, 2) + \":\" +\n        padWithZeros(minutes, 2);\n}\nexport function toHalfUTCString(date, half) {\n    const str = date.toISOString();\n    return half === \"first\"\n        ? str.substring(0, str.indexOf(\"T\"))\n        : str.substring(str.indexOf(\"T\") + 1, str.length - 1);\n}\nfunction toISOString(d, utc) {\n    if (utc) {\n        return d.toISOString();\n    }\n    else {\n        // JS Date is always local\n        const printOffset = d.kind == null ? true : d.kind === 2 /* Local */;\n        return padWithZeros(d.getFullYear(), 4) + \"-\" +\n            padWithZeros(d.getMonth() + 1, 2) + \"-\" +\n            padWithZeros(d.getDate(), 2) + \"T\" +\n            padWithZeros(d.getHours(), 2) + \":\" +\n            padWithZeros(d.getMinutes(), 2) + \":\" +\n            padWithZeros(d.getSeconds(), 2) + \".\" +\n            padWithZeros(d.getMilliseconds(), 3) +\n            (printOffset ? offsetToString(d.getTimezoneOffset() * -60000) : \"\");\n    }\n}\nfunction toISOStringWithOffset(dateWithOffset, offset) {\n    const str = dateWithOffset.toISOString();\n    return str.substring(0, str.length - 1) + offsetToString(offset);\n}\nfunction toStringWithCustomFormat(date, format, utc) {\n    return format.replace(/(\\w)\\1*/g, (match) => {\n        let rep = match;\n        switch (match.substring(0, 1)) {\n            case \"y\":\n                const y = utc ? date.getUTCFullYear() : date.getFullYear();\n                rep = match.length < 4 ? y % 100 : y;\n                break;\n            case \"M\":\n                rep = (utc ? date.getUTCMonth() : date.getMonth()) + 1;\n                break;\n            case \"d\":\n                rep = utc ? date.getUTCDate() : date.getDate();\n                break;\n            case \"H\":\n                rep = utc ? date.getUTCHours() : date.getHours();\n                break;\n            case \"h\":\n                const h = utc ? date.getUTCHours() : date.getHours();\n                rep = h > 12 ? h % 12 : h;\n                break;\n            case \"m\":\n                rep = utc ? date.getUTCMinutes() : date.getMinutes();\n                break;\n            case \"s\":\n                rep = utc ? date.getUTCSeconds() : date.getSeconds();\n                break;\n        }\n        if (rep !== match && rep < 10 && match.length > 1) {\n            rep = \"0\" + rep;\n        }\n        return rep;\n    });\n}\nexport function toStringWithOffset(date, format) {\n    const d = new Date(date.getTime() + date.offset);\n    if (!format) {\n        return d.toISOString().replace(/\\.\\d+/, \"\").replace(/[A-Z]|\\.\\d+/g, \" \") + offsetToString(date.offset);\n    }\n    else if (format.length === 1) {\n        switch (format) {\n            case \"D\":\n            case \"d\": return toHalfUTCString(d, \"first\");\n            case \"T\":\n            case \"t\": return toHalfUTCString(d, \"second\");\n            case \"O\":\n            case \"o\": return toISOStringWithOffset(d, date.offset);\n            default: throw new Error(\"Unrecognized Date print format\");\n        }\n    }\n    else {\n        return toStringWithCustomFormat(d, format, true);\n    }\n}\nexport function toStringWithKind(date, format) {\n    const utc = date.kind === 1 /* UTC */;\n    if (!format) {\n        return utc ? date.toUTCString() : date.toLocaleString();\n    }\n    else if (format.length === 1) {\n        switch (format) {\n            case \"D\":\n            case \"d\":\n                return utc ? toHalfUTCString(date, \"first\") : date.toLocaleDateString();\n            case \"T\":\n            case \"t\":\n                return utc ? toHalfUTCString(date, \"second\") : date.toLocaleTimeString();\n            case \"O\":\n            case \"o\":\n                return toISOString(date, utc);\n            default:\n                throw new Error(\"Unrecognized Date print format\");\n        }\n    }\n    else {\n        return toStringWithCustomFormat(date, format, utc);\n    }\n}\nexport function toString(date, format) {\n    return date.offset != null\n        ? toStringWithOffset(date, format)\n        : toStringWithKind(date, format);\n}\nexport default function DateTime(value, kind) {\n    kind = kind == null ? 0 /* Unspecified */ : kind;\n    const d = new Date(value);\n    d.kind = kind | 0;\n    return d;\n}\nexport function minValue() {\n    // This is \"0001-01-01T00:00:00.000Z\", actual JS min value is -8640000000000000\n    return DateTime(-62135596800000, 0 /* Unspecified */);\n}\nexport function maxValue() {\n    // This is \"9999-12-31T23:59:59.999Z\", actual JS max value is 8640000000000000\n    return DateTime(253402300799999, 0 /* Unspecified */);\n}\nexport function parseRaw(str) {\n    let date = new Date(str);\n    if (isNaN(date.getTime())) {\n        // Check if this is a time-only string, which JS Date parsing cannot handle (see #1045)\n        if (/^(?:[01]?\\d|2[0-3]):(?:[0-5]?\\d)(?::[0-5]?\\d(?:\\.\\d+)?)?(?:\\s*[AaPp][Mm])?$/.test(str)) {\n            const d = new Date();\n            date = new Date(d.getFullYear() + \"/\" + (d.getMonth() + 1) + \"/\" + d.getDate() + \" \" + str);\n        }\n        else {\n            throw new Error(\"The string is not a valid Date.\");\n        }\n    }\n    return date;\n}\nexport function parse(str, detectUTC = false) {\n    const date = parseRaw(str);\n    const offset = offsetRegex.exec(str);\n    // .NET always parses DateTime as Local if there's offset info (even \"Z\")\n    // Newtonsoft.Json uses UTC if the offset is \"Z\"\n    const kind = offset != null\n        ? (detectUTC && offset[0] === \"Z\" ? 1 /* UTC */ : 2 /* Local */)\n        : 0 /* Unspecified */;\n    return DateTime(date.getTime(), kind);\n}\nexport function tryParse(v) {\n    try {\n        return [true, parse(v)];\n    }\n    catch (_err) {\n        return [false, minValue()];\n    }\n}\nexport function offset(date) {\n    const date1 = date;\n    return typeof date1.offset === \"number\"\n        ? date1.offset\n        : (date.kind === 1 /* UTC */\n            ? 0 : date.getTimezoneOffset() * -60000);\n}\nexport function create(year, month, day, h = 0, m = 0, s = 0, ms = 0, kind) {\n    const dateValue = kind === 1 /* UTC */\n        ? Date.UTC(year, month - 1, day, h, m, s, ms)\n        : new Date(year, month - 1, day, h, m, s, ms).getTime();\n    if (isNaN(dateValue)) {\n        throw new Error(\"The parameters describe an unrepresentable Date.\");\n    }\n    const date = DateTime(dateValue, kind);\n    if (year <= 99) {\n        date.setFullYear(year, month - 1, day);\n    }\n    return date;\n}\nexport function now() {\n    return DateTime(Date.now(), 2 /* Local */);\n}\nexport function utcNow() {\n    return DateTime(Date.now(), 1 /* UTC */);\n}\nexport function today() {\n    return date(now());\n}\nexport function isLeapYear(year) {\n    return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;\n}\nexport function daysInMonth(year, month) {\n    return month === 2\n        ? (isLeapYear(year) ? 29 : 28)\n        : (month >= 8 ? (month % 2 === 0 ? 31 : 30) : (month % 2 === 0 ? 30 : 31));\n}\nexport function toUniversalTime(date) {\n    return date.kind === 1 /* UTC */ ? date : DateTime(date.getTime(), 1 /* UTC */);\n}\nexport function toLocalTime(date) {\n    return date.kind === 2 /* Local */ ? date : DateTime(date.getTime(), 2 /* Local */);\n}\nexport function timeOfDay(d) {\n    return hour(d) * 3600000\n        + minute(d) * 60000\n        + second(d) * 1000\n        + millisecond(d);\n}\nexport function date(d) {\n    return create(year(d), month(d), day(d), 0, 0, 0, 0, d.kind);\n}\nexport function day(d) {\n    return d.kind === 1 /* UTC */ ? d.getUTCDate() : d.getDate();\n}\nexport function hour(d) {\n    return d.kind === 1 /* UTC */ ? d.getUTCHours() : d.getHours();\n}\nexport function millisecond(d) {\n    return d.kind === 1 /* UTC */ ? d.getUTCMilliseconds() : d.getMilliseconds();\n}\nexport function minute(d) {\n    return d.kind === 1 /* UTC */ ? d.getUTCMinutes() : d.getMinutes();\n}\nexport function month(d) {\n    return (d.kind === 1 /* UTC */ ? d.getUTCMonth() : d.getMonth()) + 1;\n}\nexport function second(d) {\n    return d.kind === 1 /* UTC */ ? d.getUTCSeconds() : d.getSeconds();\n}\nexport function year(d) {\n    return d.kind === 1 /* UTC */ ? d.getUTCFullYear() : d.getFullYear();\n}\nexport function dayOfWeek(d) {\n    return d.kind === 1 /* UTC */ ? d.getUTCDay() : d.getDay();\n}\nexport function dayOfYear(d) {\n    const _year = year(d);\n    const _month = month(d);\n    let _day = day(d);\n    for (let i = 1; i < _month; i++) {\n        _day += daysInMonth(_year, i);\n    }\n    return _day;\n}\nexport function add(d, ts) {\n    return DateTime(d.getTime() + ts, d.kind);\n}\nexport function addDays(d, v) {\n    return DateTime(d.getTime() + v * 86400000, d.kind);\n}\nexport function addHours(d, v) {\n    return DateTime(d.getTime() + v * 3600000, d.kind);\n}\nexport function addMinutes(d, v) {\n    return DateTime(d.getTime() + v * 60000, d.kind);\n}\nexport function addSeconds(d, v) {\n    return DateTime(d.getTime() + v * 1000, d.kind);\n}\nexport function addMilliseconds(d, v) {\n    return DateTime(d.getTime() + v, d.kind);\n}\nexport function addYears(d, v) {\n    const newMonth = month(d);\n    const newYear = year(d) + v;\n    const _daysInMonth = daysInMonth(newYear, newMonth);\n    const newDay = Math.min(_daysInMonth, day(d));\n    return create(newYear, newMonth, newDay, hour(d), minute(d), second(d), millisecond(d), d.kind);\n}\nexport function addMonths(d, v) {\n    let newMonth = month(d) + v;\n    let newMonth_ = 0;\n    let yearOffset = 0;\n    if (newMonth > 12) {\n        newMonth_ = newMonth % 12;\n        yearOffset = Math.floor(newMonth / 12);\n        newMonth = newMonth_;\n    }\n    else if (newMonth < 1) {\n        newMonth_ = 12 + newMonth % 12;\n        yearOffset = Math.floor(newMonth / 12) + (newMonth_ === 12 ? -1 : 0);\n        newMonth = newMonth_;\n    }\n    const newYear = year(d) + yearOffset;\n    const _daysInMonth = daysInMonth(newYear, newMonth);\n    const newDay = Math.min(_daysInMonth, day(d));\n    return create(newYear, newMonth, newDay, hour(d), minute(d), second(d), millisecond(d), d.kind);\n}\nexport function subtract(d, that) {\n    return typeof that === \"number\"\n        ? DateTime(d.getTime() - that, d.kind)\n        : d.getTime() - that.getTime();\n}\nexport function toLongDateString(d) {\n    return d.toDateString();\n}\nexport function toShortDateString(d) {\n    return d.toLocaleDateString();\n}\nexport function toLongTimeString(d) {\n    return d.toLocaleTimeString();\n}\nexport function toShortTimeString(d) {\n    return d.toLocaleTimeString().replace(/:\\d\\d(?!:)/, \"\");\n}\nexport function equals(d1, d2) {\n    return d1.getTime() === d2.getTime();\n}\nexport function compare(x, y) {\n    const xtime = x.getTime();\n    const ytime = y.getTime();\n    return xtime === ytime ? 0 : (xtime < ytime ? -1 : 1);\n}\nexport const compareTo = compare;\nexport function op_Addition(x, y) {\n    return add(x, y);\n}\nexport function op_Subtraction(x, y) {\n    return subtract(x, y);\n}\nexport function isDaylightSavingTime(x) {\n    const jan = new Date(x.getFullYear(), 0, 1);\n    const jul = new Date(x.getFullYear(), 6, 1);\n    return isDST(jan.getTimezoneOffset(), jul.getTimezoneOffset(), x.getTimezoneOffset());\n}\nfunction isDST(janOffset, julOffset, tOffset) {\n    return Math.min(janOffset, julOffset) === tOffset;\n}\n","const types = new Map();\nexport function setType(fullName, cons) {\n    types.set(fullName, cons);\n}\nexport function getType(fullName) {\n    return types.get(fullName);\n}\nexport default {\n    reflection: Symbol(\"reflection\"),\n};\n","import { compare as compareDates, toString as dateToString } from \"./Date\";\nimport FSymbol from \"./Symbol\";\nexport class NonDeclaredType {\n    constructor(kind, definition, generics) {\n        this.kind = kind;\n        this.definition = definition;\n        this.generics = generics;\n    }\n    Equals(other) {\n        if (this.kind === other.kind && this.definition === other.definition) {\n            return typeof this.generics === \"object\"\n                // equalsRecords should also work for Type[] (tuples)\n                ? equalsRecords(this.generics, other.generics)\n                : this.generics === other.generics;\n        }\n        return false;\n    }\n}\nexport const Any = new NonDeclaredType(\"Any\");\nexport const Unit = new NonDeclaredType(\"Unit\");\nexport function Option(t) {\n    return new NonDeclaredType(\"Option\", null, [t]);\n}\nfunction FableArray(t, isTypedArray = false) {\n    let def = null;\n    let genArg = null;\n    if (isTypedArray) {\n        def = t;\n    }\n    else {\n        genArg = t;\n    }\n    return new NonDeclaredType(\"Array\", def, [genArg]);\n}\nexport { FableArray as Array };\nexport function Tuple(types) {\n    return new NonDeclaredType(\"Tuple\", null, types);\n}\nfunction FableFunction(types) {\n    return new NonDeclaredType(\"Function\", null, types);\n}\nexport { FableFunction as Function };\nexport function GenericParam(definition) {\n    return new NonDeclaredType(\"GenericParam\", definition);\n}\nexport function Interface(definition) {\n    return new NonDeclaredType(\"Interface\", definition);\n}\nexport function makeGeneric(typeDef, genArgs) {\n    return new NonDeclaredType(\"GenericType\", typeDef, genArgs);\n}\nexport function isGeneric(typ) {\n    return typ instanceof NonDeclaredType && typ.kind === \"GenericType\";\n}\n/**\n * Returns the parent if this is a declared generic type or the argument otherwise.\n * Attention: Unlike .NET this doesn't throw an exception if type is not generic.\n */\nexport function getDefinition(typ) {\n    return isGeneric(typ) ? typ.definition : typ;\n}\nexport function extendInfo(cons, info) {\n    const parent = Object.getPrototypeOf(cons.prototype);\n    if (typeof parent[FSymbol.reflection] === \"function\") {\n        const newInfo = {};\n        const parentInfo = parent[FSymbol.reflection]();\n        Object.getOwnPropertyNames(info).forEach((k) => {\n            const i = info[k];\n            if (typeof i === \"object\") {\n                newInfo[k] = Array.isArray(i)\n                    ? (parentInfo[k] || []).concat(i)\n                    : Object.assign(parentInfo[k] || {}, i);\n            }\n            else {\n                newInfo[k] = i;\n            }\n        });\n        return newInfo;\n    }\n    return info;\n}\nexport function hasInterface(obj, interfaceName) {\n    if (interfaceName === \"System.Collections.Generic.IEnumerable\") {\n        return typeof obj[Symbol.iterator] === \"function\";\n    }\n    else if (typeof obj[FSymbol.reflection] === \"function\") {\n        const interfaces = obj[FSymbol.reflection]().interfaces;\n        return Array.isArray(interfaces) && interfaces.indexOf(interfaceName) > -1;\n    }\n    return false;\n}\n/**\n * Returns:\n * - Records: array with names of fields\n * - Classes: array with names of getters\n * - Nulls and unions: empty array\n * - JS Objects: The result of calling Object.getOwnPropertyNames\n */\nexport function getPropertyNames(obj) {\n    if (obj == null) {\n        return [];\n    }\n    const propertyMap = typeof obj[FSymbol.reflection] === \"function\" ? obj[FSymbol.reflection]().properties || [] : obj;\n    return Object.getOwnPropertyNames(propertyMap);\n}\nexport function isArray(obj) {\n    return Array.isArray(obj) || ArrayBuffer.isView(obj);\n}\nexport function toString(obj, quoteStrings = false) {\n    function isObject(x) {\n        return x !== null && typeof x === \"object\" && !(x instanceof Number)\n            && !(x instanceof String) && !(x instanceof Boolean);\n    }\n    if (obj == null || typeof obj === \"number\") {\n        return String(obj);\n    }\n    if (typeof obj === \"string\") {\n        return quoteStrings ? JSON.stringify(obj) : obj;\n    }\n    if (obj instanceof Date) {\n        return dateToString(obj);\n    }\n    if (typeof obj.ToString === \"function\") {\n        return obj.ToString();\n    }\n    if (hasInterface(obj, \"FSharpUnion\")) {\n        const info = obj[FSymbol.reflection]();\n        const uci = info.cases[obj.tag];\n        switch (uci.length) {\n            case 1:\n                return uci[0];\n            case 2:\n                // For simplicity let's always use parens, in .NET they're ommitted in some cases\n                return uci[0] + \" (\" + toString(obj.data, true) + \")\";\n            default:\n                return uci[0] + \" (\" + obj.data.map((x) => toString(x, true)).join(\",\") + \")\";\n        }\n    }\n    try {\n        return JSON.stringify(obj, (k, v) => {\n            return v && v[Symbol.iterator] && !Array.isArray(v) && isObject(v) ? Array.from(v)\n                : v && typeof v.ToString === \"function\" ? toString(v) : v;\n        });\n    }\n    catch (err) {\n        // Fallback for objects with circular references\n        return \"{\" + Object.getOwnPropertyNames(obj).map((k) => k + \": \" + String(obj[k])).join(\", \") + \"}\";\n    }\n}\nexport class ObjectRef {\n    static id(o) {\n        if (!ObjectRef.idMap.has(o)) {\n            ObjectRef.idMap.set(o, ++ObjectRef.count);\n        }\n        return ObjectRef.idMap.get(o);\n    }\n}\nObjectRef.idMap = new WeakMap();\nObjectRef.count = 0;\nexport function getHashCode(x) {\n    return ObjectRef.id(x) * 2654435761 | 0;\n}\nexport function hash(x) {\n    if (typeof x === typeof 1) {\n        return x * 2654435761 | 0;\n    }\n    if (x != null && typeof x.GetHashCode === \"function\") {\n        return x.GetHashCode();\n    }\n    else {\n        const s = toString(x);\n        let h = 5381;\n        let i = 0;\n        const len = s.length;\n        while (i < len) {\n            h = (h * 33) ^ s.charCodeAt(i++);\n        }\n        return h;\n    }\n}\nexport function equals(x, y) {\n    // Optimization if they are referencially equal\n    if (x === y) {\n        return true;\n    }\n    else if (x == null) {\n        return y == null;\n    }\n    else if (y == null) {\n        return false;\n    }\n    else if (typeof x !== \"object\" || typeof y !== \"object\") {\n        return x === y;\n        // Equals override or IEquatable implementation\n    }\n    else if (typeof x.Equals === \"function\") {\n        return x.Equals(y);\n    }\n    else if (typeof y.Equals === \"function\") {\n        return y.Equals(x);\n    }\n    else if (Object.getPrototypeOf(x) !== Object.getPrototypeOf(y)) {\n        return false;\n    }\n    else if (Array.isArray(x)) {\n        if (x.length !== y.length) {\n            return false;\n        }\n        for (let i = 0; i < x.length; i++) {\n            if (!equals(x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    else if (ArrayBuffer.isView(x)) {\n        if (x.byteLength !== y.byteLength) {\n            return false;\n        }\n        const dv1 = new DataView(x.buffer);\n        const dv2 = new DataView(y.buffer);\n        for (let i = 0; i < x.byteLength; i++) {\n            if (dv1.getUint8(i) !== dv2.getUint8(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    else if (x instanceof Date) {\n        return x.getTime() === y.getTime();\n    }\n    else {\n        return false;\n    }\n}\nexport function comparePrimitives(x, y) {\n    return x === y ? 0 : (x < y ? -1 : 1);\n}\nexport function compare(x, y) {\n    // Optimization if they are referencially equal\n    if (x === y) {\n        return 0;\n    }\n    else if (x == null) {\n        return y == null ? 0 : -1;\n    }\n    else if (y == null) {\n        return 1; // everything is bigger than null\n    }\n    else if (typeof x !== \"object\" || typeof y !== \"object\") {\n        return x === y ? 0 : (x < y ? -1 : 1);\n        // Some types (see Long.ts) may just implement the function and not the interface\n        // else if (hasInterface(x, \"System.IComparable\"))\n    }\n    else if (typeof x.CompareTo === \"function\") {\n        return x.CompareTo(y);\n    }\n    else if (typeof y.CompareTo === \"function\") {\n        return y.CompareTo(x) * -1;\n    }\n    else if (Object.getPrototypeOf(x) !== Object.getPrototypeOf(y)) {\n        return -1;\n    }\n    else if (Array.isArray(x)) {\n        if (x.length !== y.length) {\n            return x.length < y.length ? -1 : 1;\n        }\n        for (let i = 0, j = 0; i < x.length; i++) {\n            j = compare(x[i], y[i]);\n            if (j !== 0) {\n                return j;\n            }\n        }\n        return 0;\n    }\n    else if (ArrayBuffer.isView(x)) {\n        if (x.byteLength !== y.byteLength) {\n            return x.byteLength < y.byteLength ? -1 : 1;\n        }\n        const dv1 = new DataView(x.buffer);\n        const dv2 = new DataView(y.buffer);\n        for (let i = 0, b1 = 0, b2 = 0; i < x.byteLength; i++) {\n            b1 = dv1.getUint8(i), b2 = dv2.getUint8(i);\n            if (b1 < b2) {\n                return -1;\n            }\n            if (b1 > b2) {\n                return 1;\n            }\n        }\n        return 0;\n    }\n    else if (x instanceof Date) {\n        return compareDates(x, y);\n    }\n    else if (typeof x === \"object\") {\n        const xhash = hash(x);\n        const yhash = hash(y);\n        if (xhash === yhash) {\n            return equals(x, y) ? 0 : -1;\n        }\n        else {\n            return xhash < yhash ? -1 : 1;\n        }\n    }\n    else {\n        return x < y ? -1 : 1;\n    }\n}\nexport function lessThan(x, y) {\n    return compare(x, y) < 0;\n}\nexport function lessOrEqual(x, y) {\n    return compare(x, y) <= 0;\n}\nexport function greaterThan(x, y) {\n    return compare(x, y) > 0;\n}\nexport function greaterOrEqual(x, y) {\n    return compare(x, y) >= 0;\n}\nexport function equalsRecords(x, y) {\n    // Optimization if they are referencially equal\n    if (x === y) {\n        return true;\n    }\n    else {\n        const keys = getPropertyNames(x);\n        for (const key of keys) {\n            if (!equals(x[key], y[key])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nexport function compareRecords(x, y) {\n    // Optimization if they are referencially equal\n    if (x === y) {\n        return 0;\n    }\n    else {\n        const keys = getPropertyNames(x);\n        for (const key of keys) {\n            const res = compare(x[key], y[key]);\n            if (res !== 0) {\n                return res;\n            }\n        }\n        return 0;\n    }\n}\nexport function equalsUnions(x, y) {\n    return x === y || (x.tag === y.tag && equals(x.data, y.data));\n}\nexport function compareUnions(x, y) {\n    if (x === y) {\n        return 0;\n    }\n    else {\n        const res = x.tag < y.tag ? -1 : (x.tag > y.tag ? 1 : 0);\n        return res !== 0 ? res : compare(x.data, y.data);\n    }\n}\nexport function createDisposable(f) {\n    return {\n        Dispose: f,\n        [FSymbol.reflection]() { return { interfaces: [\"System.IDisposable\"] }; },\n    };\n}\n// tslint forbids non-arrow functions, but it's\n// necessary here to use the arguments object\n/* tslint:disable */\nexport function createAtom(value) {\n    let atom = value;\n    return function () {\n        return arguments.length === 0\n            ? atom\n            : (atom = arguments[0], void 0);\n    };\n}\n/* tslint:enable */\nconst CaseRules = {\n    None: 0,\n    LowerFirst: 1,\n};\nfunction isList(o) {\n    if (o != null) {\n        if (typeof o[FSymbol.reflection] === \"function\") {\n            return o[FSymbol.reflection]().type === \"Microsoft.FSharp.Collections.FSharpList\";\n        }\n    }\n    return false;\n}\nexport function createObj(fields, caseRule = CaseRules.None, casesCache) {\n    const iter = fields[Symbol.iterator]();\n    let cur = iter.next();\n    const o = {};\n    while (!cur.done) {\n        const value = cur.value;\n        if (Array.isArray(value)) {\n            o[value[0]] = value[1];\n        }\n        else {\n            casesCache = casesCache || new Map();\n            const proto = Object.getPrototypeOf(value);\n            let cases = casesCache.get(proto);\n            if (cases == null) {\n                if (typeof proto[FSymbol.reflection] === \"function\") {\n                    cases = proto[FSymbol.reflection]().cases;\n                    casesCache.set(proto, cases);\n                }\n            }\n            const caseInfo = (cases != null) ? cases[value.tag] : null;\n            if (Array.isArray(caseInfo)) {\n                let key = caseInfo[0];\n                if (caseRule === CaseRules.LowerFirst) {\n                    key = key[0].toLowerCase() + key.substr(1);\n                }\n                o[key] = caseInfo.length === 1\n                    ? true\n                    : (isList(value.data) ? createObj(value.data, caseRule, casesCache) : value.data);\n            }\n            else {\n                throw new Error(\"Cannot infer key and value of \" + value);\n            }\n        }\n        cur = iter.next();\n    }\n    return o;\n}\nexport function toPlainJsObj(source) {\n    if (source != null && source.constructor !== Object) {\n        const target = {};\n        let props = Object.getOwnPropertyNames(source);\n        for (const p of props) {\n            target[p] = source[p];\n        }\n        // Copy also properties from prototype, see #192\n        const proto = Object.getPrototypeOf(source);\n        if (proto != null) {\n            props = Object.getOwnPropertyNames(proto);\n            for (const p of props) {\n                const prop = Object.getOwnPropertyDescriptor(proto, p);\n                if (prop.value) {\n                    target[p] = prop.value;\n                }\n                else if (prop.get) {\n                    target[p] = prop.get.apply(source);\n                }\n            }\n        }\n        return target;\n    }\n    else {\n        return source;\n    }\n}\nexport function jsOptions(mutator) {\n    const opts = {};\n    mutator(opts);\n    return opts;\n}\nexport function round(value, digits = 0) {\n    const m = Math.pow(10, digits);\n    const n = +(digits ? value * m : value).toFixed(8);\n    const i = Math.floor(n);\n    const f = n - i;\n    const e = 1e-8;\n    const r = (f > 0.5 - e && f < 0.5 + e) ? ((i % 2 === 0) ? i : i + 1) : Math.round(n);\n    return digits ? r / m : r;\n}\nexport function sign(x) {\n    return x > 0 ? 1 : x < 0 ? -1 : 0;\n}\nexport function randomNext(min, max) {\n    return Math.floor(Math.random() * (max - min)) + min;\n}\nexport function applyOperator(x, y, operator) {\n    function getMethod(obj) {\n        if (typeof obj === \"object\") {\n            const cons = Object.getPrototypeOf(obj).constructor;\n            if (typeof cons[operator] === \"function\") {\n                return cons[operator];\n            }\n        }\n        return null;\n    }\n    let meth = getMethod(x);\n    if (meth != null) {\n        return meth(x, y);\n    }\n    meth = getMethod(y);\n    if (meth != null) {\n        return meth(x, y);\n    }\n    switch (operator) {\n        case \"op_Addition\":\n            return x + y;\n        case \"op_Subtraction\":\n            return x - y;\n        case \"op_Multiply\":\n            return x * y;\n        case \"op_Division\":\n            return x / y;\n        case \"op_Modulus\":\n            return x % y;\n        case \"op_LeftShift\":\n            return x << y;\n        case \"op_RightShift\":\n            return x >> y;\n        case \"op_BitwiseAnd\":\n            return x & y;\n        case \"op_BitwiseOr\":\n            return x | y;\n        case \"op_ExclusiveOr\":\n            return x ^ y;\n        case \"op_LogicalNot\":\n            return x + y;\n        case \"op_UnaryNegation\":\n            return !x;\n        case \"op_BooleanAnd\":\n            return x && y;\n        case \"op_BooleanOr\":\n            return x || y;\n        default:\n            return null;\n    }\n}\nexport function unescapeDataString(s) {\n    // https://stackoverflow.com/a/4458580/524236\n    return decodeURIComponent((s).replace(/\\+/g, \"%20\"));\n}\nexport function escapeDataString(s) {\n    return encodeURIComponent(s).replace(/!/g, \"%21\")\n        .replace(/'/g, \"%27\")\n        .replace(/\\(/g, \"%28\")\n        .replace(/\\)/g, \"%29\")\n        .replace(/\\*/g, \"%2A\");\n}\nexport function escapeUriString(s) {\n    return encodeURI(s);\n}\n// ICollection.Clear method can be called on IDictionary\n// too so we need to make a runtime check (see #1120)\nexport function clear(col) {\n    if (Array.isArray(col)) {\n        col.splice(0);\n    }\n    else {\n        col.clear();\n    }\n}\n","import { compare, equals, toString } from \"./Util\";\nexport class Some {\n    constructor(value) {\n        this.value = value;\n    }\n    // We don't prefix it with \"Some\" for consistency with erased options\n    ToString() {\n        return toString(this.value);\n    }\n    Equals(other) {\n        if (other == null) {\n            return false;\n        }\n        else {\n            return equals(this.value, other instanceof Some\n                ? other.value : other);\n        }\n    }\n    CompareTo(other) {\n        if (other == null) {\n            return 1;\n        }\n        else {\n            return compare(this.value, other instanceof Some\n                ? other.value : other);\n        }\n    }\n}\nexport function makeSome(x) {\n    return x == null || x instanceof Some ? new Some(x) : x;\n}\nexport function getValue(x, acceptNull) {\n    if (x == null) {\n        if (!acceptNull) {\n            throw new Error(\"Option has no value\");\n        }\n        return null;\n    }\n    else {\n        return x instanceof Some ? x.value : x;\n    }\n}\nexport function defaultArg(arg, defaultValue, f) {\n    return arg == null ? defaultValue : (f != null ? f(getValue(arg)) : getValue(arg));\n}\nexport function defaultArgWith(arg, defThunk) {\n    return arg == null ? defThunk() : getValue(arg);\n}\nexport function filter(predicate, arg) {\n    return arg != null ? (!predicate(getValue(arg)) ? null : arg) : arg;\n}\n","import FSymbol from \"./Symbol\";\nimport { toString } from \"./Util\";\nimport { equals } from \"./Util\";\nimport { compare } from \"./Util\";\n// This module is split from List.ts to prevent cyclic dependencies\nexport function ofArray(args, base) {\n    let acc = base || new List();\n    for (let i = args.length - 1; i >= 0; i--) {\n        acc = new List(args[i], acc);\n    }\n    return acc;\n}\nexport default class List {\n    constructor(head, tail) {\n        this.head = head;\n        this.tail = tail;\n    }\n    ToString() {\n        return \"[\" + Array.from(this).map((x) => toString(x)).join(\"; \") + \"]\";\n    }\n    Equals(other) {\n        // Optimization if they are referencially equal\n        if (this === other) {\n            return true;\n        }\n        else {\n            let cur1 = this;\n            let cur2 = other;\n            while (equals(cur1.head, cur2.head)) {\n                cur1 = cur1.tail;\n                cur2 = cur2.tail;\n                if (cur1 == null) {\n                    return cur2 == null;\n                }\n            }\n            return false;\n        }\n    }\n    CompareTo(other) {\n        // Optimization if they are referencially equal\n        if (this === other) {\n            return 0;\n        }\n        else {\n            let cur1 = this;\n            let cur2 = other;\n            let res = compare(cur1.head, cur2.head);\n            while (res === 0) {\n                cur1 = cur1.tail;\n                cur2 = cur2.tail;\n                if (cur1 == null) {\n                    return cur2 == null ? 0 : -1;\n                }\n                res = compare(cur1.head, cur2.head);\n            }\n            return res;\n        }\n    }\n    get length() {\n        let cur = this;\n        let acc = 0;\n        while (cur.tail != null) {\n            cur = cur.tail;\n            acc++;\n        }\n        return acc;\n    }\n    [Symbol.iterator]() {\n        let cur = this;\n        return {\n            next: () => {\n                const tmp = cur;\n                cur = cur.tail;\n                return { done: tmp.tail == null, value: tmp.head };\n            },\n        };\n    }\n    //   append(ys: List<T>): List<T> {\n    //     return append(this, ys);\n    //   }\n    //   choose<U>(f: (x: T) => U, xs: List<T>): List<U> {\n    //     return choose(f, this);\n    //   }\n    //   collect<U>(f: (x: T) => List<U>): List<U> {\n    //     return collect(f, this);\n    //   }\n    //   filter(f: (x: T) => boolean): List<T> {\n    //     return filter(f, this);\n    //   }\n    //   where(f: (x: T) => boolean): List<T> {\n    //     return filter(f, this);\n    //   }\n    //   map<U>(f: (x: T) => U): List<U> {\n    //     return map(f, this);\n    //   }\n    //   mapIndexed<U>(f: (i: number, x: T) => U): List<U> {\n    //     return mapIndexed(f, this);\n    //   }\n    //   partition(f: (x: T) => boolean): [List<T>, List<T>] {\n    //     return partition(f, this) as [List<T>, List<T>];\n    //   }\n    //   reverse(): List<T> {\n    //     return reverse(this);\n    //   }\n    //   slice(lower: number, upper: number): List<T> {\n    //     return slice(lower, upper, this);\n    //   }\n    [FSymbol.reflection]() {\n        return {\n            type: \"Microsoft.FSharp.Collections.FSharpList\",\n            interfaces: [\"System.IEquatable\", \"System.IComparable\"],\n        };\n    }\n}\n","import { permute as arrayPermute } from \"./Array\";\nimport { chunkBySize as arrayChunkBySize } from \"./Array\";\nimport List from \"./ListClass\";\nimport { getValue, makeSome } from \"./Option\";\nimport { compare, equals } from \"./Util\";\nexport class Enumerator {\n    constructor(iter) {\n        this.iter = iter;\n    }\n    MoveNext() {\n        const cur = this.iter.next();\n        this.current = cur.value;\n        return !cur.done;\n    }\n    get Current() { return this.current; }\n    get get_Current() { return this.current; }\n    Reset() {\n        throw new Error(\"JS iterators cannot be reset\");\n    }\n    Dispose() { return; }\n}\nexport function getEnumerator(o) {\n    return typeof o.GetEnumerator === \"function\"\n        ? o.GetEnumerator() : new Enumerator(o[Symbol.iterator]());\n}\nexport function toIterator(en) {\n    return {\n        next() {\n            return en.MoveNext()\n                ? { done: false, value: en.Current }\n                : { done: true, value: null };\n        },\n    };\n}\nfunction __failIfNone(res) {\n    if (res == null) {\n        throw new Error(\"Seq did not contain any matching element\");\n    }\n    return getValue(res);\n}\nexport function toList(xs) {\n    return foldBack((x, acc) => new List(x, acc), xs, new List());\n}\nexport function ofList(xs) {\n    return delay(() => unfold((x) => x.tail != null ? [x.head, x.tail] : null, xs));\n}\nexport function ofArray(xs) {\n    return delay(() => unfold((i) => i < xs.length ? [xs[i], i + 1] : null, 0));\n}\nexport function append(xs, ys) {\n    return delay(() => {\n        let firstDone = false;\n        const i = xs[Symbol.iterator]();\n        let iters = [i, null];\n        return unfold(() => {\n            let cur;\n            if (!firstDone) {\n                cur = iters[0].next();\n                if (!cur.done) {\n                    return [cur.value, iters];\n                }\n                else {\n                    firstDone = true;\n                    iters = [null, ys[Symbol.iterator]()];\n                }\n            }\n            cur = iters[1].next();\n            return !cur.done ? [cur.value, iters] : null;\n        }, iters);\n    });\n}\nexport function average(xs) {\n    let count = 1;\n    const sum = reduce((acc, x) => {\n        count++;\n        return acc + x;\n    }, xs);\n    return sum / count;\n}\nexport function averageBy(f, xs) {\n    let count = 1;\n    const sum = reduce((acc, x) => {\n        count++;\n        return (count === 2 ? f(acc) : acc) + f(x);\n    }, xs);\n    return sum / count;\n}\nexport function concat(xs) {\n    return delay(() => {\n        const iter = xs[Symbol.iterator]();\n        let output = { value: null };\n        return unfold((innerIter) => {\n            let hasFinished = false;\n            while (!hasFinished) {\n                if (innerIter == null) {\n                    const cur = iter.next();\n                    if (!cur.done) {\n                        innerIter = cur.value[Symbol.iterator]();\n                    }\n                    else {\n                        hasFinished = true;\n                    }\n                }\n                else {\n                    const cur = innerIter.next();\n                    if (!cur.done) {\n                        output = { value: cur.value };\n                        hasFinished = true;\n                    }\n                    else {\n                        innerIter = null;\n                    }\n                }\n            }\n            return innerIter != null && output != null ? [output.value, innerIter] : null;\n        }, null);\n    });\n}\nexport function collect(f, xs) {\n    return concat(map(f, xs));\n}\nexport function choose(f, xs) {\n    return delay(() => unfold((iter) => {\n        let cur = iter.next();\n        while (!cur.done) {\n            const y = f(cur.value);\n            if (y != null) {\n                return [getValue(y), iter];\n            }\n            cur = iter.next();\n        }\n        return null;\n    }, xs[Symbol.iterator]()));\n}\nexport function compareWith(f, xs, ys) {\n    const nonZero = tryFind((i) => i !== 0, map2((x, y) => f(x, y), xs, ys));\n    return nonZero != null ? getValue(nonZero) : count(xs) - count(ys);\n}\nexport function delay(f) {\n    return {\n        [Symbol.iterator]: () => f()[Symbol.iterator](),\n    };\n}\nexport function empty() {\n    return unfold(() => void 0);\n}\nexport function enumerateWhile(cond, xs) {\n    return concat(unfold(() => cond() ? [xs, true] : null));\n}\nexport function enumerateThenFinally(xs, finalFn) {\n    return delay(() => {\n        let iter;\n        try {\n            iter = xs[Symbol.iterator]();\n        }\n        catch (err) {\n            return void 0;\n        }\n        finally {\n            finalFn();\n        }\n        return unfold((it) => {\n            try {\n                const cur = it.next();\n                return !cur.done ? [cur.value, it] : null;\n            }\n            catch (err) {\n                return void 0;\n            }\n            finally {\n                finalFn();\n            }\n        }, iter);\n    });\n}\nexport function enumerateUsing(disp, work) {\n    let isDisposed = false;\n    const disposeOnce = () => {\n        if (!isDisposed) {\n            isDisposed = true;\n            disp.Dispose();\n        }\n    };\n    try {\n        return enumerateThenFinally(work(disp), disposeOnce);\n    }\n    catch (err) {\n        return void 0;\n    }\n    finally {\n        disposeOnce();\n    }\n}\nexport function exactlyOne(xs) {\n    const iter = xs[Symbol.iterator]();\n    const fst = iter.next();\n    if (fst.done) {\n        throw new Error(\"Seq was empty\");\n    }\n    const snd = iter.next();\n    if (!snd.done) {\n        throw new Error(\"Seq had multiple items\");\n    }\n    return fst.value;\n}\nexport function except(itemsToExclude, source) {\n    const exclusionItems = Array.from(itemsToExclude);\n    const testIsNotInExclusionItems = (element) => !exclusionItems.some((excludedItem) => equals(excludedItem, element));\n    return filter(testIsNotInExclusionItems, source);\n}\nexport function exists(f, xs) {\n    let cur;\n    for (const iter = xs[Symbol.iterator]();;) {\n        cur = iter.next();\n        if (cur.done) {\n            break;\n        }\n        if (f(cur.value)) {\n            return true;\n        }\n    }\n    return false;\n}\nexport function exists2(f, xs, ys) {\n    let cur1;\n    let cur2;\n    for (const iter1 = xs[Symbol.iterator](), iter2 = ys[Symbol.iterator]();;) {\n        cur1 = iter1.next();\n        cur2 = iter2.next();\n        if (cur1.done || cur2.done) {\n            break;\n        }\n        if (f(cur1.value, cur2.value)) {\n            return true;\n        }\n    }\n    return false;\n}\nexport function filter(f, xs) {\n    return delay(() => unfold((iter) => {\n        let cur = iter.next();\n        while (!cur.done) {\n            if (f(cur.value)) {\n                return [cur.value, iter];\n            }\n            cur = iter.next();\n        }\n        return null;\n    }, xs[Symbol.iterator]()));\n}\nexport function where(f, xs) {\n    return filter(f, xs);\n}\nexport function fold(f, acc, xs) {\n    if (Array.isArray(xs) || ArrayBuffer.isView(xs)) {\n        return xs.reduce(f, acc);\n    }\n    else {\n        let cur;\n        for (let i = 0, iter = xs[Symbol.iterator]();; i++) {\n            cur = iter.next();\n            if (cur.done) {\n                break;\n            }\n            acc = f(acc, cur.value, i);\n        }\n        return acc;\n    }\n}\nexport function foldBack(f, xs, acc) {\n    const arr = Array.isArray(xs) || ArrayBuffer.isView(xs) ? xs : Array.from(xs);\n    for (let i = arr.length - 1; i >= 0; i--) {\n        acc = f(arr[i], acc, i);\n    }\n    return acc;\n}\nexport function fold2(f, acc, xs, ys) {\n    const iter1 = xs[Symbol.iterator]();\n    const iter2 = ys[Symbol.iterator]();\n    let cur1;\n    let cur2;\n    for (let i = 0;; i++) {\n        cur1 = iter1.next();\n        cur2 = iter2.next();\n        if (cur1.done || cur2.done) {\n            break;\n        }\n        acc = f(acc, cur1.value, cur2.value, i);\n    }\n    return acc;\n}\nexport function foldBack2(f, xs, ys, acc) {\n    const ar1 = Array.isArray(xs) || ArrayBuffer.isView(xs) ? xs : Array.from(xs);\n    const ar2 = Array.isArray(ys) || ArrayBuffer.isView(ys) ? ys : Array.from(ys);\n    for (let i = ar1.length - 1; i >= 0; i--) {\n        acc = f(ar1[i], ar2[i], acc, i);\n    }\n    return acc;\n}\nexport function forAll(f, xs) {\n    return fold((acc, x) => acc && f(x), true, xs);\n}\nexport function forAll2(f, xs, ys) {\n    return fold2((acc, x, y) => acc && f(x, y), true, xs, ys);\n}\nexport function tryHead(xs) {\n    const iter = xs[Symbol.iterator]();\n    const cur = iter.next();\n    return cur.done ? null : makeSome(cur.value);\n}\nexport function head(xs) {\n    return __failIfNone(tryHead(xs));\n}\nexport function initialize(n, f) {\n    return delay(() => unfold((i) => i < n ? [f(i), i + 1] : null, 0));\n}\nexport function initializeInfinite(f) {\n    return delay(() => unfold((i) => [f(i), i + 1], 0));\n}\nexport function tryItem(i, xs) {\n    if (i < 0) {\n        return null;\n    }\n    if (Array.isArray(xs) || ArrayBuffer.isView(xs)) {\n        return i < xs.length ? makeSome(xs[i]) : null;\n    }\n    for (let j = 0, iter = xs[Symbol.iterator]();; j++) {\n        const cur = iter.next();\n        if (cur.done) {\n            break;\n        }\n        if (j === i) {\n            return makeSome(cur.value);\n        }\n    }\n    return null;\n}\nexport function item(i, xs) {\n    return __failIfNone(tryItem(i, xs));\n}\nexport function iterate(f, xs) {\n    fold((_, x) => f(x), null, xs);\n}\nexport function iterate2(f, xs, ys) {\n    fold2((_, x, y) => f(x, y), null, xs, ys);\n}\nexport function iterateIndexed(f, xs) {\n    fold((_, x, i) => f(i, x), null, xs);\n}\nexport function iterateIndexed2(f, xs, ys) {\n    fold2((_, x, y, i) => f(i, x, y), null, xs, ys);\n}\nexport function isEmpty(xs) {\n    const i = xs[Symbol.iterator]();\n    return i.next().done;\n}\nexport function tryLast(xs) {\n    try {\n        return makeSome(reduce((_, x) => x, xs));\n    }\n    catch (err) {\n        return null;\n    }\n}\nexport function last(xs) {\n    return __failIfNone(tryLast(xs));\n}\n// A export function 'length' method causes problems in JavaScript -- https://github.com/Microsoft/TypeScript/issues/442\nexport function count(xs) {\n    return Array.isArray(xs) || ArrayBuffer.isView(xs)\n        ? xs.length\n        : fold((acc, x) => acc + 1, 0, xs);\n}\nexport function map(f, xs) {\n    return delay(() => unfold((iter) => {\n        const cur = iter.next();\n        return !cur.done ? [f(cur.value), iter] : null;\n    }, xs[Symbol.iterator]()));\n}\nexport function mapIndexed(f, xs) {\n    return delay(() => {\n        let i = 0;\n        return unfold((iter) => {\n            const cur = iter.next();\n            return !cur.done ? [f(i++, cur.value), iter] : null;\n        }, xs[Symbol.iterator]());\n    });\n}\nexport function indexed(xs) {\n    return mapIndexed((i, x) => [i, x], xs);\n}\nexport function map2(f, xs, ys) {\n    return delay(() => {\n        const iter1 = xs[Symbol.iterator]();\n        const iter2 = ys[Symbol.iterator]();\n        return unfold(() => {\n            const cur1 = iter1.next();\n            const cur2 = iter2.next();\n            return !cur1.done && !cur2.done ? [f(cur1.value, cur2.value), null] : null;\n        });\n    });\n}\nexport function mapIndexed2(f, xs, ys) {\n    return delay(() => {\n        let i = 0;\n        const iter1 = xs[Symbol.iterator]();\n        const iter2 = ys[Symbol.iterator]();\n        return unfold(() => {\n            const cur1 = iter1.next();\n            const cur2 = iter2.next();\n            return !cur1.done && !cur2.done ? [f(i++, cur1.value, cur2.value), null] : null;\n        });\n    });\n}\nexport function map3(f, xs, ys, zs) {\n    return delay(() => {\n        const iter1 = xs[Symbol.iterator]();\n        const iter2 = ys[Symbol.iterator]();\n        const iter3 = zs[Symbol.iterator]();\n        return unfold(() => {\n            const cur1 = iter1.next();\n            const cur2 = iter2.next();\n            const cur3 = iter3.next();\n            return !cur1.done && !cur2.done && !cur3.done ? [f(cur1.value, cur2.value, cur3.value), null] : null;\n        });\n    });\n}\nexport function chunkBySize(size, xs) {\n    const result = arrayChunkBySize(size, Array.from(xs));\n    return ofArray(result);\n}\nexport function mapFold(f, acc, xs, transform) {\n    const result = [];\n    let r;\n    let cur;\n    for (let i = 0, iter = xs[Symbol.iterator]();; i++) {\n        cur = iter.next();\n        if (cur.done) {\n            break;\n        }\n        [r, acc] = f(acc, cur.value);\n        result.push(r);\n    }\n    return transform !== void 0 ? [transform(result), acc] : [result, acc];\n}\nexport function mapFoldBack(f, xs, acc, transform) {\n    const arr = Array.isArray(xs) || ArrayBuffer.isView(xs) ? xs : Array.from(xs);\n    const result = [];\n    let r;\n    for (let i = arr.length - 1; i >= 0; i--) {\n        [r, acc] = f(arr[i], acc);\n        result.push(r);\n    }\n    return transform !== void 0 ? [transform(result), acc] : [result, acc];\n}\nexport function max(xs) {\n    return reduce((acc, x) => compare(acc, x) === 1 ? acc : x, xs);\n}\nexport function maxBy(f, xs) {\n    return reduce((acc, x) => compare(f(acc), f(x)) === 1 ? acc : x, xs);\n}\nexport function min(xs) {\n    return reduce((acc, x) => compare(acc, x) === -1 ? acc : x, xs);\n}\nexport function minBy(f, xs) {\n    return reduce((acc, x) => compare(f(acc), f(x)) === -1 ? acc : x, xs);\n}\nexport function pairwise(xs) {\n    return skip(2, scan((last, next) => [last[1], next], [0, 0], xs));\n}\nexport function permute(f, xs) {\n    return ofArray(arrayPermute(f, Array.from(xs)));\n}\nexport function rangeStep(first, step, last) {\n    if (step === 0) {\n        throw new Error(\"Step cannot be 0\");\n    }\n    return delay(() => unfold((x) => step > 0 && x <= last || step < 0 && x >= last ? [x, x + step] : null, first));\n}\nexport function rangeChar(first, last) {\n    return delay(() => unfold((x) => x <= last ? [x, String.fromCharCode(x.charCodeAt(0) + 1)] : null, first));\n}\nexport function range(first, last) {\n    return rangeStep(first, 1, last);\n}\nexport function readOnly(xs) {\n    return map((x) => x, xs);\n}\nexport function reduce(f, xs) {\n    if (Array.isArray(xs) || ArrayBuffer.isView(xs)) {\n        return xs.reduce(f);\n    }\n    const iter = xs[Symbol.iterator]();\n    let cur = iter.next();\n    if (cur.done) {\n        throw new Error(\"Seq was empty\");\n    }\n    let acc = cur.value;\n    while (true) {\n        cur = iter.next();\n        if (cur.done) {\n            break;\n        }\n        acc = f(acc, cur.value);\n    }\n    return acc;\n}\nexport function reduceBack(f, xs) {\n    const ar = Array.isArray(xs) || ArrayBuffer.isView(xs) ? xs : Array.from(xs);\n    if (ar.length === 0) {\n        throw new Error(\"Seq was empty\");\n    }\n    let acc = ar[ar.length - 1];\n    for (let i = ar.length - 2; i >= 0; i--) {\n        acc = f(ar[i], acc, i);\n    }\n    return acc;\n}\nexport function replicate(n, x) {\n    return initialize(n, () => x);\n}\nexport function reverse(xs) {\n    const ar = Array.isArray(xs) || ArrayBuffer.isView(xs) ? xs.slice(0) : Array.from(xs);\n    return ofArray(ar.reverse());\n}\nexport function scan(f, seed, xs) {\n    return delay(() => {\n        const iter = xs[Symbol.iterator]();\n        return unfold((acc) => {\n            if (acc == null) {\n                return [seed, seed];\n            }\n            const cur = iter.next();\n            if (!cur.done) {\n                acc = f(acc, cur.value);\n                return [acc, acc];\n            }\n            return void 0;\n        }, null);\n    });\n}\nexport function scanBack(f, xs, seed) {\n    return reverse(scan((acc, x) => f(x, acc), seed, reverse(xs)));\n}\nexport function singleton(y) {\n    return unfold((x) => x != null ? [x, null] : null, y);\n}\nexport function skip(n, xs) {\n    return {\n        [Symbol.iterator]: () => {\n            const iter = xs[Symbol.iterator]();\n            for (let i = 1; i <= n; i++) {\n                if (iter.next().done) {\n                    throw new Error(\"Seq has not enough elements\");\n                }\n            }\n            return iter;\n        },\n    };\n}\nexport function skipWhile(f, xs) {\n    return delay(() => {\n        let hasPassed = false;\n        return filter((x) => hasPassed || (hasPassed = !f(x)), xs);\n    });\n}\nexport function sortWith(f, xs) {\n    const ys = Array.from(xs);\n    return ofArray(ys.sort(f));\n}\nexport function sum(xs) {\n    return fold((acc, x) => acc + x, 0, xs);\n}\nexport function sumBy(f, xs) {\n    return fold((acc, x) => acc + f(x), 0, xs);\n}\nexport function tail(xs) {\n    const iter = xs[Symbol.iterator]();\n    const cur = iter.next();\n    if (cur.done) {\n        throw new Error(\"Seq was empty\");\n    }\n    return {\n        [Symbol.iterator]: () => iter,\n    };\n}\nexport function take(n, xs, truncate = false) {\n    return delay(() => {\n        const iter = xs[Symbol.iterator]();\n        return unfold((i) => {\n            if (i < n) {\n                const cur = iter.next();\n                if (!cur.done) {\n                    return [cur.value, i + 1];\n                }\n                if (!truncate) {\n                    throw new Error(\"Seq has not enough elements\");\n                }\n            }\n            return void 0;\n        }, 0);\n    });\n}\nexport function truncate(n, xs) {\n    return take(n, xs, true);\n}\nexport function takeWhile(f, xs) {\n    return delay(() => {\n        const iter = xs[Symbol.iterator]();\n        return unfold((i) => {\n            const cur = iter.next();\n            if (!cur.done && f(cur.value)) {\n                return [cur.value, null];\n            }\n            return void 0;\n        }, 0);\n    });\n}\nexport function tryFind(f, xs, defaultValue) {\n    for (let i = 0, iter = xs[Symbol.iterator]();; i++) {\n        const cur = iter.next();\n        if (cur.done) {\n            break;\n        }\n        if (f(cur.value, i)) {\n            return makeSome(cur.value);\n        }\n    }\n    return defaultValue === void 0 ? null : makeSome(defaultValue);\n}\nexport function find(f, xs) {\n    return __failIfNone(tryFind(f, xs));\n}\nexport function tryFindBack(f, xs, defaultValue) {\n    const arr = Array.isArray(xs) || ArrayBuffer.isView(xs) ? xs.slice(0) : Array.from(xs);\n    return tryFind(f, arr.reverse(), defaultValue);\n}\nexport function findBack(f, xs) {\n    return __failIfNone(tryFindBack(f, xs));\n}\nexport function tryFindIndex(f, xs) {\n    for (let i = 0, iter = xs[Symbol.iterator]();; i++) {\n        const cur = iter.next();\n        if (cur.done) {\n            break;\n        }\n        if (f(cur.value, i)) {\n            return i;\n        }\n    }\n    return null;\n}\nexport function findIndex(f, xs) {\n    return __failIfNone(tryFindIndex(f, xs));\n}\nexport function tryFindIndexBack(f, xs) {\n    const arr = Array.isArray(xs) || ArrayBuffer.isView(xs) ? xs.slice(0) : Array.from(xs);\n    for (let i = arr.length - 1; i >= 0; i--) {\n        if (f(arr[i], i)) {\n            return i;\n        }\n    }\n    return null;\n}\nexport function findIndexBack(f, xs) {\n    return __failIfNone(tryFindIndexBack(f, xs));\n}\nexport function tryPick(f, xs) {\n    for (let i = 0, iter = xs[Symbol.iterator]();; i++) {\n        const cur = iter.next();\n        if (cur.done) {\n            break;\n        }\n        const y = f(cur.value, i);\n        if (y != null) {\n            return y;\n        }\n    }\n    return null;\n}\nexport function pick(f, xs) {\n    return __failIfNone(tryPick(f, xs));\n}\nexport function unfold(f, fst) {\n    return {\n        [Symbol.iterator]: () => {\n            // Capture a copy of the first value in the closure\n            // so the sequence is restarted every time, see #1230\n            let acc = fst;\n            return {\n                next: () => {\n                    const res = f(acc);\n                    if (res != null) {\n                        acc = res[1];\n                        return { done: false, value: res[0] };\n                    }\n                    return { done: true };\n                },\n            };\n        },\n    };\n}\nexport function zip(xs, ys) {\n    return map2((x, y) => [x, y], xs, ys);\n}\nexport function zip3(xs, ys, zs) {\n    return map3((x, y, z) => [x, y, z], xs, ys, zs);\n}\n","import List from \"./ListClass\";\nimport { ofArray } from \"./ListClass\";\nimport { groupBy as mapGroupBy } from \"./Map\";\nimport { getValue } from \"./Option\";\nimport { map as seqMap } from \"./Seq\";\nimport { fold as seqFold } from \"./Seq\";\nimport { foldBack as seqFoldBack } from \"./Seq\";\nimport { toList as seqToList } from \"./Seq\";\nexport default List;\nexport { ofArray };\nexport function append(xs, ys) {\n    return seqFold((acc, x) => new List(x, acc), ys, reverse(xs));\n}\nexport function choose(f, xs) {\n    const r = seqFold((acc, x) => {\n        const y = f(x);\n        return y != null ? new List(getValue(y), acc) : acc;\n    }, new List(), xs);\n    return reverse(r);\n}\nexport function collect(f, xs) {\n    return seqFold((acc, x) => append(acc, f(x)), new List(), xs);\n}\n// TODO: should be xs: Iterable<List<T>>\nexport function concat(xs) {\n    return collect((x) => x, xs);\n}\nexport function filter(f, xs) {\n    return reverse(seqFold((acc, x) => f(x) ? new List(x, acc) : acc, new List(), xs));\n}\nexport function where(f, xs) {\n    return filter(f, xs);\n}\nexport function initialize(n, f) {\n    if (n < 0) {\n        throw new Error(\"List length must be non-negative\");\n    }\n    let xs = new List();\n    for (let i = 1; i <= n; i++) {\n        xs = new List(f(n - i), xs);\n    }\n    return xs;\n}\nexport function map(f, xs) {\n    return reverse(seqFold((acc, x) => new List(f(x), acc), new List(), xs));\n}\nexport function mapIndexed(f, xs) {\n    return reverse(seqFold((acc, x, i) => new List(f(i, x), acc), new List(), xs));\n}\nexport function indexed(xs) {\n    return mapIndexed((i, x) => [i, x], xs);\n}\nexport function partition(f, xs) {\n    return seqFold((acc, x) => {\n        const lacc = acc[0];\n        const racc = acc[1];\n        return f(x) ? [new List(x, lacc), racc] : [lacc, new List(x, racc)];\n    }, [new List(), new List()], reverse(xs));\n}\nexport function replicate(n, x) {\n    return initialize(n, () => x);\n}\nexport function reverse(xs) {\n    return seqFold((acc, x) => new List(x, acc), new List(), xs);\n}\nexport function singleton(x) {\n    return new List(x, new List());\n}\nexport function slice(lower, upper, xs) {\n    const noLower = (lower == null);\n    const noUpper = (upper == null);\n    return reverse(seqFold((acc, x, i) => (noLower || lower <= i) && (noUpper || i <= upper) ? new List(x, acc) : acc, new List(), xs));\n}\n/* ToDo: instance unzip() */\nexport function unzip(xs) {\n    return seqFoldBack((xy, acc) => [new List(xy[0], acc[0]), new List(xy[1], acc[1])], xs, [new List(), new List()]);\n}\n/* ToDo: instance unzip3() */\nexport function unzip3(xs) {\n    return seqFoldBack((xyz, acc) => [new List(xyz[0], acc[0]), new List(xyz[1], acc[1]), new List(xyz[2], acc[2]),\n    ], xs, [new List(), new List(), new List(),\n    ]);\n}\nexport function groupBy(f, xs) {\n    return seqToList(seqMap((k) => [k[0], seqToList(k[1])], mapGroupBy(f, xs)));\n}\nexport function splitAt(index, xs) {\n    if (index < 0) {\n        throw new Error(\"The input must be non-negative.\");\n    }\n    let i = 0;\n    let last = xs;\n    const first = new Array(index);\n    while (i < index) {\n        if (last.tail == null) {\n            throw new Error(\"The input sequence has an insufficient number of elements.\");\n        }\n        first[i] = last.head;\n        last = last.tail;\n        i++;\n    }\n    return [ofArray(first), last];\n}\nexport function head(xs) {\n    if (xs.head !== undefined) {\n        return xs.head;\n    }\n    else {\n        throw new Error(\"The input list was empty.\");\n    }\n}\nexport function tail(xs) {\n    if (xs.tail !== undefined) {\n        return xs.tail;\n    }\n    else {\n        throw new Error(\"The input list was empty.\");\n    }\n}\n","export function create(pattern, options) {\n    let flags = \"g\";\n    flags += options & 1 ? \"i\" : \"\";\n    flags += options & 2 ? \"m\" : \"\";\n    return new RegExp(pattern, flags);\n}\n// From http://stackoverflow.com/questions/3446170/escape-string-for-use-in-javascript-regex\nexport function escape(str) {\n    return str.replace(/[\\-\\[\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\");\n}\nexport function unescape(str) {\n    return str.replace(/\\\\([\\-\\[\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|])/g, \"$1\");\n}\nexport function isMatch(str, pattern, options = 0) {\n    let reg;\n    reg = str instanceof RegExp\n        ? (reg = str, str = pattern, reg.lastIndex = options, reg)\n        : reg = create(pattern, options);\n    return reg.test(str);\n}\nexport function match(str, pattern, options = 0) {\n    let reg;\n    reg = str instanceof RegExp\n        ? (reg = str, str = pattern, reg.lastIndex = options, reg)\n        : reg = create(pattern, options);\n    return reg.exec(str);\n}\nexport function matches(str, pattern, options = 0) {\n    let reg;\n    reg = str instanceof RegExp\n        ? (reg = str, str = pattern, reg.lastIndex = options, reg)\n        : reg = create(pattern, options);\n    if (!reg.global) {\n        throw new Error(\"Non-global RegExp\"); // Prevent infinite loop\n    }\n    let m = reg.exec(str);\n    const matches = [];\n    while (m !== null) {\n        matches.push(m);\n        m = reg.exec(str);\n    }\n    return matches;\n}\nexport function options(reg) {\n    let options = 256; // ECMAScript\n    options |= reg.ignoreCase ? 1 : 0;\n    options |= reg.multiline ? 2 : 0;\n    return options;\n}\nexport function replace(reg, input, replacement, limit, offset = 0) {\n    function replacer() {\n        let res = arguments[0];\n        if (limit !== 0) {\n            limit--;\n            const match = [];\n            const len = arguments.length;\n            for (let i = 0; i < len - 2; i++) {\n                match.push(arguments[i]);\n            }\n            match.index = arguments[len - 2];\n            match.input = arguments[len - 1];\n            res = replacement(match);\n        }\n        return res;\n    }\n    if (typeof reg === \"string\") {\n        const tmp = reg;\n        reg = create(input, limit);\n        input = tmp;\n        limit = undefined;\n    }\n    if (typeof replacement === \"function\") {\n        limit = limit == null ? -1 : limit;\n        return input.substring(0, offset) + input.substring(offset).replace(reg, replacer);\n    }\n    else {\n        // $0 doesn't work with JS regex, see #1155\n        replacement = replacement.replace(/\\$0/g, (s) => \"$&\");\n        if (limit != null) {\n            let m;\n            const sub1 = input.substring(offset);\n            const _matches = matches(reg, sub1);\n            const sub2 = matches.length > limit ? (m = _matches[limit - 1], sub1.substring(0, m.index + m[0].length)) : sub1;\n            return input.substring(0, offset) + sub2.replace(reg, replacement)\n                + input.substring(offset + sub2.length);\n        }\n        else {\n            return input.replace(reg, replacement);\n        }\n    }\n}\nexport function split(reg, input, limit, offset = 0) {\n    if (typeof reg === \"string\") {\n        const tmp = reg;\n        reg = create(input, limit);\n        input = tmp;\n        limit = undefined;\n    }\n    input = input.substring(offset);\n    return input.split(reg, limit);\n}\n","module HtmlParser.Parser.Tokenizer\n\nopen System.Text.RegularExpressions\n\ntype TokenType =\n    | OpeningComment\n    | ClosingComment\n    | LeftAngleBracket\n    | RightAngleBracket\n    | EqualSign\n    | DoubleQuoteMark\n    | SingleQuoteMark\n    | ForwardSlash\n    | ExclamationMark\n    | Dash\n    | Whitespace\n    | Word\n\ntype Chars = char list\n\ntype TokenValue = string\n\ntype Token = TokenType * TokenValue\n\ntype Tokens = Token list\n\ntype TokenRecipe = TokenType * string\n\ntype RemainderString = string\n\nlet reservedCharTokenLookup : TokenRecipe list =\n    [ LeftAngleBracket, \"<\"\n      RightAngleBracket, \">\"\n      EqualSign, \"=\"\n      DoubleQuoteMark, \"\\\"\"\n      SingleQuoteMark, \"'\"\n      ForwardSlash, \"/\"\n      Dash, \"-\" ]\n\nlet commentSequences : TokenRecipe list =\n    [ OpeningComment, \"<!--\"\n      ClosingComment, \"-->\" ]\n\nlet wordRegex : string =\n    \"[^<>=\\\"'\\/-\\\\s]+\"\n\nlet doubleQuotedStringRegex : string =\n    \"\"\"[^\\\\\"]+\"\"\"\n\nlet wildcards : TokenRecipe list =\n    [ Whitespace, \"(\\\\s)+\"\n      Word, wordRegex ]\n\nlet tokenizerGrammar : TokenRecipe list =\n    commentSequences @ reservedCharTokenLookup @ wildcards\n\nlet consumeToken ((tokenType , regexString ) : TokenRecipe) (str : string) : (Token * RemainderString) option  =\n    let regex = Regex(\"^\" + regexString)\n    let matches = regex.Matches str |> Seq.cast<Match> |> Seq.toList\n    match matches with\n    | [] ->\n        None\n\n    | head::_ ->\n        let token = (tokenType, head.Value)\n        let remainder = regex.Replace(str, \"\", 1)\n\n        Some(token, remainder)\n\nlet rec consumeFirstTokenMatch (tokenRecipes : TokenRecipe list) (str : string) : (Token * RemainderString) option =\n    match tokenRecipes with\n    | [] ->\n        None\n\n    | tokenRecipe :: tailTokenRecipes ->\n        match consumeToken tokenRecipe str with\n        | None ->\n            consumeFirstTokenMatch tailTokenRecipes str\n\n        | Some result ->\n            Some result\n\nlet tokenize (str : string) : Token list =\n    let rec internalTokenize accTokens reminderString =\n        match consumeFirstTokenMatch tokenizerGrammar reminderString with\n        | None ->\n            accTokens\n\n        | Some (token, remainderRemainderString) ->\n            internalTokenize (accTokens @ [ token ]) remainderRemainderString\n\n    internalTokenize [] str\n","module Tests.Tokenizer\n\nopen HtmlParser.Parser.Tokenizer\nopen QUnit\n\nlet tests _ =\n    registerModule(\"HtmlParser.Parser.Tokenizer\")\n\n    testCase \"consumeToken `<` token\" <| fun test ->\n        consumeToken (LeftAngleBracket, \"<\") \"<br/>\"\n        |> function\n            | None -> test.failwith \"Token `<` not consumed\"\n            | Some (token, remainderString) ->\n                test.deepEqual (LeftAngleBracket, \"<\") token\n                test.equal \"br/>\" remainderString\n\n    testCase \"consumeToken `>` token\" <| fun test ->\n        consumeToken (RightAngleBracket, \">\") \">some text\"\n        |> function\n            | None -> test.failwith \"Token `>` not consumed\"\n            | Some (token, remainderString) ->\n                test.deepEqual (RightAngleBracket, \">\") token\n                test.equal \"some text\" remainderString\n\n    testCase \"consumeToken `=` token\" <| fun test ->\n        consumeToken (EqualSign, \"=\") \"='my-value'\"\n        |> function\n            | None -> test.failwith \"Token `=` not consumed\"\n            | Some (token, remainderString) ->\n                test.deepEqual (EqualSign, \"=\") token\n                test.equal \"'my-value'\" remainderString\n\n    testCase \"consumeToken `\\\"` token\" <| fun test ->\n        consumeToken (DoubleQuoteMark, \"\\\"\") \"\\\"my-value\\\"\"\n        |> function\n            | None -> test.failwith \"Token `\\\"` not consumed\"\n            | Some (token, remainderString) ->\n                test.deepEqual (DoubleQuoteMark, \"\\\"\") token\n                test.equal \"my-value\\\"\" remainderString\n\n    testCase \"consumeToken `'` token\" <| fun test ->\n        consumeToken (SingleQuoteMark, \"'\") \"'my-value'\"\n        |> function\n            | None -> test.failwith \"Token `'` not consumed\"\n            | Some (token, remainderString) ->\n                test.deepEqual (SingleQuoteMark, \"'\") token\n                test.equal \"my-value'\" remainderString\n\n    testCase \"consumeToken `/` token\" <| fun test ->\n        consumeToken (ForwardSlash, \"/\") \"/>some text'\"\n        |> function\n            | None -> test.failwith \"Token `/` not consumed\"\n            | Some (token, remainderString) ->\n                test.deepEqual (ForwardSlash, \"/\") token\n                test.equal \">some text'\" remainderString\n\n    testCase \"consumeToken `-` token\" <| fun test ->\n        consumeToken (Dash, \"-\") \"-value\"\n        |> function\n            | None -> test.failwith \"Token `-` not consumed\"\n            | Some (token, remainderString) ->\n                test.deepEqual (Dash, \"-\") token\n                test.equal \"value\" remainderString\n\n    testCase \"consumeWhitespace\" <| fun test ->\n        consumeToken wildcards.Head \"    test\"\n        |> function\n            | None -> test.failwith \"Whitespace token not consumed\"\n            | Some (token, remainderString) ->\n                test.deepEqual (Whitespace, \"    \") token\n                test.equal \"test\" remainderString\n\n    testCase \"consumeFirstTokenMatch OpeningComment\" <| fun test ->\n        consumeFirstTokenMatch tokenizerGrammar \"<!-- A comment -->\"\n        |> function\n            | None -> test.fail()\n            | Some (token, remainderString) ->\n                test.deepEqual (OpeningComment, \"<!--\") token\n                test.equal \" A comment -->\" remainderString\n\n    testCase \"tokenize\" <| fun test ->\n        let tokens = tokenize \"<div>Hello, I am a test</div>\"\n\n        let expected =\n            [ LeftAngleBracket, \"<\"\n              Word, \"div\"\n              RightAngleBracket, \">\"\n              Word, \"Hello,\"\n              Whitespace, \" \"\n              Word, \"I\"\n              Whitespace, \" \"\n              Word, \"am\"\n              Whitespace, \" \"\n              Word, \"a\"\n              Whitespace, \" \"\n              Word, \"test\"\n              LeftAngleBracket, \"<\"\n              ForwardSlash, \"/\"\n              Word, \"div\"\n              RightAngleBracket, \">\" ]\n\n        test.deepEqual expected tokens\n","module Tests.Main\n\nTests.Tokenizer.tests ()\n"],"names":["toString","dateToString","equals","compare","compareDates","append","seqFold","reverse","head","create","matches_1"],"mappings":"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"}